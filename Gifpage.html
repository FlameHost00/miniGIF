<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>miniGIF - Коллекция эмоций и танцев</title>
    <style>
        :root {
            --primary: #4361ee;
            --secondary: #3f37c9;
            --success: #4cc9f0;
            --danger: #f72585;
            --warning: #f8961e;
            --light: #f8f9fa;
            --dark: #212529;
            --hujlusha: #ff6b6b;
            --bg-color: rgba(0, 0, 0, 0.95);
            --header-bg: rgba(67, 97, 238, 0.8);
        }

        /* Новые стили для фона */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 30px;
            background-color: #0a0a1a;
            position: relative;
            overflow-x: hidden;
            line-height: 1.6;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 40px;
            font-size: 2.5rem;
            font-weight: 600;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 12px;
            text-shadow: 0 0 10px var(--primary);
            backdrop-filter: blur(5px);
        }

        h2 {
            color: white;
            border-bottom: 2px solid var(--primary);
            padding-bottom: 12px;
            margin-top: 50px;
            font-size: 1.8rem;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(5px);
        }

        .category-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .category-btn {
            position: relative;
            padding: 12px 40px 12px 20px;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            font-weight: 500;
            margin: 5px;
            text-align: left;
            overflow: visible;
        }

        .category-btn:hover {
            background-color: var(--secondary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }


        .control-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .category-btn.active {
            background-color: var(--success);
            color: var(--dark);
            border: 2px solid white;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.8),
                0 4px 12px rgba(0, 0, 0, 0.3);
            transform: translateY(-2px) scale(1.02);
            text-shadow:
                1px 0 0 white,
                0 1px 0 white,
                -1px 0 0 white,
                0 -1px 0 white;
        }

        .category-btn:hover .delete-category-btn {
            opacity: 1;
        }

        /* Новые стили для верхнего меню */
        .header-menu {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid var(--primary);
        }

        .menu-btn {
            padding: 12px 20px;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
            font-weight: 500;
        }

        .menu-btn:hover {
            background-color: var(--secondary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .data-actions-menu {
            position: relative;
            display: inline-block;
        }

        .data-actions-dropdown {
            display: none;
            position: absolute;
            background-color: rgba(0, 0, 0, 0.9);
            min-width: 200px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
            z-index: 1;
            border-radius: 8px;
            border: 1px solid var(--primary);
            padding: 10px 0;
        }

        .data-actions-dropdown button {
            color: white;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            width: 100%;
            text-align: left;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
        }

        .data-actions-dropdown button:hover {
            background-color: rgba(67, 97, 238, 0.5);
        }

        .data-actions-menu:hover .data-actions-dropdown {
            display: block;
        }

        /* Стили для выпадающего меню категорий для перемещения и копирования */

        .category-dropdown {
            display: none;
            position: absolute;
            background-color: rgba(0, 0, 0, 0.9);
            min-width: 200px;
            max-height: 300px;
            overflow-y: auto;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
            z-index: 1;
            border-radius: 8px;
            border: 1px solid var(--primary);
            padding: 10px 0;
        }

        .category-dropdown button {
            color: white;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            width: 100%;
            text-align: left;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
        }

        .category-dropdown-btn:hover {
            border-color: var(--success);
        }

        .category-dropdown-container {
            flex-grow: 1;
            position: relative;
        }

        .category-dropdown-btn {
            width: 100%;
            padding: 6px 10px;
            /* Уменьшенные отступы */
            font-size: 13px;
            border-radius: 5px;
            border: 1px solid var(--primary);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            text-align: left;
            cursor: pointer;
            position: relative;
            padding-right: 25px;
            transition: all 0.2s;
        }

        .category-dropdown-btn::after {
            content: "▼";
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 9px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .category-dropdown-btn:hover::after {
            opacity: 1;
        }

        .move-container,
        .copy-container {
            position: relative;
            width: 100%;
        }

        .action-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .action-label {
            color: white;
            font-weight: 500;
            min-width: 70px;
            /* Уменьшенная ширина */
            text-align: left;
            /* Выравнивание по левому краю */
            flex-shrink: 0;
        }

        .action-controls {
            flex-grow: 1;
            display: flex;
            gap: 5px;
        }

        .action-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
            margin-top: 8px;
        }

        .category-dropdown-container {
            flex-grow: 1;
            position: relative;
            min-width: 0;
            /* Убираем ограничение минимальной ширины */
        }

        /* Обновленные стили для цветового колеса */
        .color-picker-container {
            display: flex;
            align-items: center;
            gap: 30px;
            margin-top: 20px;
        }

        .color-wheel-wrapper {
            position: relative;
            width: 220px;
            height: 220px;
            border-radius: 50%;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .color-wheel {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(red 0deg, yellow 60deg, lime 120deg,
                    cyan 180deg, blue 240deg, magenta 300deg, red 360deg);
            cursor: crosshair;
            transition: transform 0.2s;
        }

        .color-wheel:hover {
            transform: scale(1.02);
        }

        .color-wheel-selector {
            position: absolute;
            width: 14px;
            height: 14px;
            border: 3px solid white;
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
            transform: translate(-50%, -50%);
            z-index: 2;
        }

        .color-preview-large {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            border: 3px solid white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: background-color 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .color-value {
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 12px;
            border-radius: 6px;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        .color-palette-wrapper {
            position: relative;
            width: 220px;
            height: 220px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            overflow: hidden;
            cursor: crosshair;
        }

        #colorPalette {
            width: 100%;
            height: 100%;
            display: block;
        }

        .palette-selector {
            position: absolute;
            width: 14px;
            height: 14px;
            border: 3px solid white;
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
            transform: translate(-50%, -50%);
            z-index: 2;
        }

        /* Увеличиваем модальное окно */
        .modal-content {
            max-width: 500px;
        }

        .form-row {
            grid-template-columns: 120px 1fr;
        }

        .items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 20px;
        }

        .item-container {
            display: grid;
            grid-template-columns: 1fr 200px;
            align-items: center;
            margin-bottom: 25px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            gap: 15px;
            border: 1px solid var(--primary);
            position: relative;
        }

        .item-code {
            font-family: 'Courier New', Courier, monospace;
            color: white;
            font-weight: bold;
            font-size: 16px;
            display: flex;
            align-items: center;
            word-break: break-word;
        }

        .copy-btn {
            margin-right: 12px;
            padding: 8px 12px;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .copy-btn:hover {
            background-color: var(--secondary);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .gif-container {
            width: 180px;
            height: 140px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--primary);
            transition: all 0.3s;
            position: relative;
        }

        .gif-container:hover {
            transform: scale(1.02);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
        }

        .gif-container img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .gif-delete-btn {
            position: absolute;
            top: 5px;
            left: 5px;
            background: transparent url('https://cdn-icons-png.flaticon.com/512/1182/1182766.png') no-repeat center;
            background-size: contain;
            width: 20px;
            height: 20px;
            border: none;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
            padding: 0;
        }

        .gif-delete-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        .gif-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .action-btn {
            width: 100%;
            padding: 8px;
            font-size: 14px;
        }

        .move-container,
        .copy-container {
            display: flex;
            width: 100%;
            gap: 5px;
        }

        .move-btn {
            background-color: var(--warning);
            color: var(--dark);
            padding: 8px 12px;
            font-size: 14px;
            font-weight: 600;
            white-space: nowrap;
            min-width: 50px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
        }

        .copy-btn-action {
            background-color: var(--success);
            color: var(--dark);
            padding: 8px 12px;
            font-size: 14px;
            font-weight: 600;
            white-space: nowrap;
            min-width: 50px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
        }

        .move-select,
        .copy-select {
            flex-grow: 1;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid var(--primary);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        button {
            padding: 12px 20px;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
            font-weight: 500;
        }

        button:hover {
            background-color: var(--secondary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .category {
            margin-top: 60px;
            display: none;
        }

        .category.active {
            display: block;
        }

        .copied-notice {
            position: fixed;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--success);
            color: white;
            padding: 15px 30px;
            border-radius: 8px;
            z-index: 1000;
            display: none;
            font-size: 16px;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.3);
            animation: fadeIn 0.4s;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translate(-50%, -15px);
            }

            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }

        .add-new-form {
            margin-top: 40px;
            padding: 30px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--primary);
        }

        .add-new-form h3 {
            margin-top: 0;
            color: white;
            font-size: 1.5rem;
            margin-bottom: 25px;
            font-weight: 600;
        }

        .new-category-form {
            margin-top: 40px;
            padding: 30px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--primary);
        }

        .new-category-form h3 {
            margin-top: 0;
            color: white;
            font-size: 1.5rem;
            margin-bottom: 25px;
            font-weight: 600;
        }

        .form-row {
            display: grid;
            grid-template-columns: 150px 1fr;
            margin-bottom: 20px;
            align-items: center;
            gap: 20px;
        }

        .form-row label {
            font-weight: 500;
            color: white;
            font-size: 16px;
        }

        .form-row input,
        .form-row select {
            padding: 13px 16px;
            font-size: 16px;
            border: 1px solid var(--primary);
            border-radius: 8px;
            transition: all 0.2s;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
        }

        .form-row input:focus,
        .form-row select:focus {
            border-color: var(--success);
            outline: none;
            box-shadow: 0 0 0 4px rgba(76, 201, 240, 0.2);
        }

        .form-actions {
            display: flex;
            justify-content: flex-end;
            margin-top: 30px;
            gap: 15px;
        }

        .data-actions {
            margin-top: 40px;
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        .data-actions button {
            background-color: var(--warning);
            color: var(--dark);
            font-weight: 600;
            padding: 15px 25px;
            font-size: 16px;
        }

        .data-actions button:hover {
            background-color: #e68a00;
            color: white;
        }

        .category-color {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            cursor: pointer;
            border: 2px solid white;
        }

        .color-palette {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .color-option.selected {
            border-color: white;
            transform: scale(1.1);
        }


        /* Стили для модального окна настроек */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 2147483647;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: var(--bg-color);
            border: 2px solid var(--primary);
            border-radius: 10px;
            padding: 20px;
            width: 400px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-header h3 {
            margin: 0;
            color: white;
        }

        .close-modal {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
        }

        /* Добавьте этот стиль в секцию стилей */
        #toggleGifPanelBtn {
            background-color: #8a2be2;
            /* Фиолетовый цвет */
            border: 2px solid white;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            transition: all 0.3s ease;
        }

        #toggleGifPanelBtn:hover {
            background-color: #9932cc;
            /* Более темный фиолетовый при наведении */
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.9);
        }

        .edit-category-btn {
            background-color: rgba(76, 201, 240, 0.7);
        }

        .edit-category-btn:hover {
            background-color: rgba(76, 201, 240, 1);
        }

        /* Иконки для кнопок меню */
        .category-dropdown-menu button::before {
            font-size: 16px;
            width: 20px;
            text-align: center;
        }

        .category-dropdown-menu button.edit-btn::before {
            content: '✎';
        }

        .category-dropdown-menu button.delete-btn::before {
            content: '×';
            font-weight: bold;
        }

        /* Выпадающее меню категории */
        .category-dropdown-menu {
            display: none;
            position: absolute;
            right: 0;
            top: calc(100% + 5px);
            background-color: rgba(0, 0, 0, 0.95);
            min-width: 160px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            z-index: 10;
            border-radius: 8px;
            border: 1px solid var(--primary);
            padding: 8px 0;
        }

        .category-dropdown-menu.show {
            display: block;
        }

        .category-dropdown-menu button {
            color: white;
            padding: 8px 16px;
            text-decoration: none;
            display: block;
            width: 100%;
            text-align: left;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .category-dropdown-menu button:hover {
            background-color: rgba(67, 97, 238, 0.3);
        }

        .category-dropdown-menu button.edit-btn {
            color: var(--success);
        }

        .category-dropdown-menu button.delete-btn {
            color: var(--danger);
        }

        /* Кнопка меню (три точки) */
        .category-menu-trigger {
            position: absolute;
            right: 8px;
            top: 8px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            border: 2px solid rgb(72, 122, 168);
            color: rgb(72, 122, 168);
            cursor: pointer;
            opacity: 0.7;
            transition: all 0.2s;
            padding: 0;
        }

        .category-menu-trigger:hover {
            opacity: 1;
            background: rgba(255, 255, 255, 0.3);
        }

        /* Стили модального меню выбора категории при экспорте */
        .categories-checkbox-container {
            max-height: 300px;
            overflow-y: auto;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .category-checkbox-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            padding: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
        }

        .category-checkbox-item input {
            margin-right: 10px;
        }

        .category-checkbox-item label {
            flex-grow: 1;
            color: white;
            cursor: pointer;
        }

        .category-color-preview {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-left: 10px;
            border: 1px solid white;
        }

        /* Космический фон с светящимися линиями */
        .space-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: radial-gradient(ellipse at bottom, #1B2735 0%, #090A0F 100%);
            overflow: hidden;
        }

        /* Светящиеся линии */
        .glowing-line {
            position: absolute;
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            transform-origin: left center;
            animation: moveLine linear infinite;
        }

        @keyframes moveLine {
            0% {
                transform: translateX(-100%) rotate(0deg);
                opacity: 0;
            }

            10% {
                opacity: 0.8;
            }

            90% {
                opacity: 0.8;
            }

            100% {
                transform: translateX(100vw) rotate(0deg);
                opacity: 0;
            }
        }

        /* Боковые надписи MiniNika */
        .side-logo {
            position: fixed;
            font-size: 4rem;
            font-weight: bold;
            color: transparent;
            -webkit-text-stroke: 1px rgba(255, 255, 255, 0.2);
            z-index: -1;
            opacity: 0.2;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
            pointer-events: none;
            animation: floatSide 8s ease-in-out infinite;
        }

        .side-logo.left {
            left: 30px;
            top: 30%;
        }

        .side-logo.right {
            right: 30px;
            bottom: 30%;
        }

        @keyframes floatSide {

            0%,
            100% {
                transform: translateY(0) rotate(-2deg);
            }

            25% {
                transform: translateY(-15px) rotate(0deg);
            }

            50% {
                transform: translateY(0) rotate(2deg);
            }

            75% {
                transform: translateY(15px) rotate(0deg);
            }
        }

        /* Эффект светящихся линий для букв */
        .side-logo::before {
            content: "MiniNika";
            position: absolute;
            top: 0;
            left: 0;
            color: transparent;
            -webkit-text-stroke: 1px rgba(255, 255, 255, 0.3);
            z-index: -1;
            animation: lineGlow 3s ease-in-out infinite alternate;
        }

        @keyframes lineGlow {
            0% {
                opacity: 0.2;
                text-shadow: 0 0 5px rgba(255, 255, 255, 0.2);
            }

            100% {
                opacity: 0.4;
                text-shadow: 0 0 15px rgba(255, 255, 255, 0.4);
            }
        }

        /* Звезды */
        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle var(--duration) ease-in-out infinite;
        }

        @keyframes twinkle {

            0%,
            100% {
                opacity: 0.2;
                transform: scale(0.8);
            }

            50% {
                opacity: 1;
                transform: scale(1.2);
            }
        }

        /* Системное окно */
        .title-bar {
            -webkit-app-region: drag;
            height: 30px;
            background-color: #2d2d2d;
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
        }

        .window-controls {
            -webkit-app-region: no-drag;
            display: flex;
        }

        .window-controls button {
            background: none;
            border: none;
            color: white;
            padding: 5px 15px;
            cursor: pointer;
        }

        .window-controls button:hover {
            background-color: #3d3d3d;
        }

        .window-controls #close-btn:hover {
            background-color: #e81123;
        }

        /* Кастомный скроллбар */
        html {
            scroll-behavior: smooth;
        }

        body {
            scrollbar-width: thin;
            scrollbar-color: var(--primary) rgba(0, 0, 0, 0.3);
        }

        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
            background-color: rgba(0, 0, 0, 0.1);
        }

        ::-webkit-scrollbar-track {
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            margin: 5px;
        }

        ::-webkit-scrollbar-thumb {
            background-color: var(--primary);
            border-radius: 6px;
            border: 2px solid rgba(0, 0, 0, 0.3);
        }

        ::-webkit-scrollbar-thumb:hover {
            background-color: var(--secondary);
        }

        ::-webkit-scrollbar-corner {
            background-color: transparent;
        }

        /* Специальные стили для модальных окон и выпадающих списков */
        .modal-content::-webkit-scrollbar,
        .category-dropdown::-webkit-scrollbar,
        .data-actions-dropdown::-webkit-scrollbar {
            width: 8px;
        }

        .modal-content::-webkit-scrollbar-track,
        .category-dropdown::-webkit-scrollbar-track,
        .data-actions-dropdown::-webkit-scrollbar-track {
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content::-webkit-scrollbar-thumb,
        .category-dropdown::-webkit-scrollbar-thumb,
        .data-actions-dropdown::-webkit-scrollbar-thumb {
            background-color: var(--success);
        }

        .modal-content {
            pointer-events: auto !important;
        }

        /* Кнопка редактировать гиф */
        .edit-btn {
            background-color: var(--warning);
            color: var(--dark);
            padding: 8px 12px;
            font-size: 14px;
            font-weight: 600;
            white-space: nowrap;
            min-width: 50px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
        }

        .edit-btn:hover {
            background-color: #e68a00;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .edit-controls {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .gif-edit-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .gif-url-edit {
            width: 100%;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid var(--primary);
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            margin-top: 5px;
            display: none;
        }
    </style>
</head>

<body>
    <div class="title-bar">
        <div class="title"></div>
        <div class="window-controls">
            <button id="minimize-btn">—</button>
            <button id="maximize-btn">□</button>
            <button id="close-btn">×</button>
        </div>
    </div>

    <!-- Космический фон -->
    <div class="space-background">
        <div class="stars" id="stars"></div>
        <div class="side-logo left">MiniNika</div>
        <div class="side-logo right">MiniNika</div>
    </div>

    <h1>Коллекция эмоций и танцев</h1>
    <div class="copied-notice" id="copiedNotice">Скопировано!</div>

    <!-- Верхнее меню -->
    <div class="header-menu">
        <button id="toggleGifPanelBtn" class="menu-btn">Открыть GIF панель</button>
        <button id="openAddGifModal" class="menu-btn">+ Добавить GIF</button>
        <button id="openAddCategoryModal" class="menu-btn">+ Добавить категорию</button>

        <div class="data-actions-menu">
            <button class="menu-btn">Экспорт / Импорт GIF ▼</button>
            <div class="data-actions-dropdown">
                <button id="exportBtn">Экспорт GIF</button>
                <button id="importBtn">Импорт GIF</button>
            </div>
        </div>
    </div>

    <div class="category-selector" id="categorySelector">
        <!-- Категории будут добавляться динамически -->
    </div>

    <div id="listContainer">
        <!-- Категории будут добавляться динамически -->
    </div>

    <!-- Модальное окно подтверждения -->
    <div id="confirmModal" class="modal">
        <div class="modal-content" style="width: 400px;">
            <div class="modal-header">
                <h3 id="confirmModalTitle">Подтверждение</h3>
                <button class="close-modal" onclick="closeConfirmModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p id="confirmModalMessage">Вы уверены?</p>
            </div>
            <div class="modal-footer">
                <button id="confirmModalYes" class="confirm-btn">Да</button>
                <button id="confirmModalNo" class="cancel-btn">Нет</button>
            </div>
        </div>
    </div>

    <!-- Модальное окно для добавления гифки -->
    <div id="addGifModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Добавить новый элемент</h3>
                <button class="close-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-row">
                    <label for="newCategory">Категория:</label>
                    <select id="newCategory"></select>
                </div>
                <div class="form-row">
                    <label for="newCode">Код:</label>
                    <input type="text" id="newCode" tabindex="0" placeholder=":minipoka">
                </div>
                <div class="form-row">
                    <label for="newGifUrl">URL GIF:</label>
                    <input type="text" id="newGifUrl" tabindex="0" placeholder="https://example.com/image.gif">
                </div>
            </div>
            <div class="modal-footer">
                <button id="addNewBtn">Добавить</button>
                <button class="cancel-btn">Отмена</button>
            </div>
        </div>
    </div>

    <!-- Модальное окно для редактирования категории -->
    <div id="editCategoryModal" class="modal">
        <div class="modal-content" style="width: 500px;">
            <div class="modal-header">
                <h3>Редактировать категорию</h3>
                <button class="close-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-row">
                    <label for="editCategoryName">Название:</label>
                    <input type="text" id="editCategoryName" tabindex="0" placeholder="Название категории">
                </div>
                <div class="form-row">
                    <label>Цвет:</label>
                    <div class="color-picker-container">
                        <div class="color-palette-wrapper">
                            <canvas id="editColorPalette" width="220" height="220"></canvas>
                            <div class="palette-selector" id="editPaletteSelector"></div>
                        </div>
                        <div class="color-preview-large" id="editColorPreview">
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="saveCategoryBtn">Сохранить</button>
                <button class="cancel-btn">Отмена</button>
            </div>
        </div>
    </div>

    <!-- Модальное окно для добавления категории (обновлено с цветовым колесом) -->
    <div id="addCategoryModal" class="modal">
        <div class="modal-content" style="width: 500px;">
            <div class="modal-header">
                <h3>Создать новую категорию</h3>
                <button class="close-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-row">
                    <label for="newCategoryName">Название:</label>
                    <input type="text" id="newCategoryName" placeholder="Моя новая категория">
                </div>
                <div class="form-row">
                    <label>Цвет:</label>
                    <div class="color-picker-container">
                        <div class="color-palette-wrapper">
                            <canvas id="colorPalette" width="220" height="220"></canvas>
                            <div class="palette-selector" id="paletteSelector"></div>
                        </div>
                        <div class="color-preview-large" id="colorPreview">
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="createCategoryBtn">Создать</button>
                <button class="cancel-btn">Отмена</button>
            </div>
        </div>
    </div>

    <!-- Модальное окно для выбора категории при экспорте-->
    <div id="exportModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Экспорт данных</h3>
                <button class="close-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-row">
                    <label>Выберите категории для экспорта:</label>
                    <div class="categories-checkbox-container">
                        <!-- Категории будут добавлены динамически -->
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="confirmExportBtn">Экспортировать выбранное</button>
                <button class="cancel-btn">Отмена</button>
            </div>
        </div>
    </div>


    <script>
        const path = require('path');
        const { ipcRenderer } = require('electron');

        // Категории и данные теперь загружаются из файла
        let categories = [];
        let itemsData = {};
        let selectedColor = "#4361ee";

        // Состояние GIF панели
        const panelState = {
            currentCategory: null,
            isPinned: false,
            isDragging: false,
            dragOffsetX: 0,
            dragOffsetY: 0,
            isMinimized: false,
            isDraggingCategory: false,
            draggedCategoryIndex: null,
            hotkeys: {
                toggle: { key: 'g', ctrl: true, shift: true },
                categories: [
                    { key: '1', ctrl: false, shift: false },
                    { key: '2', ctrl: false, shift: false },
                    { key: '3', ctrl: false, shift: false },
                    { key: '4', ctrl: false, shift: false },
                    { key: '5', ctrl: false, shift: false },
                    { key: '6', ctrl: false, shift: false },
                    { key: '7', ctrl: false, shift: false },
                    { key: '8', ctrl: false, shift: false },
                    { key: '9', ctrl: false, shift: false }
                ]
            }
        };

        // Функция для генерации уникального ID
        function generateId() {
            return Date.now();
        }

        // Функция для создания ключа категории
        function createCategoryKey(name) {
            return name.toLowerCase().replace(/[^a-z0-9а-яё]/g, '-').replace(/-+/g, '-');
        }

        // Функция для получения данных категории по ID
        function getCategoryData(categoryId) {
            return itemsData[categoryId] || [];
        }

        // Функция для получения категории по ID
        function getCategoryById(categoryId) {
            return categories.find(c => c.id === categoryId);
        }

        // Функция для копирования кода
        function copyCode(code) {
            const textToCopy = code + ' ';
            navigator.clipboard.writeText(textToCopy).then(() => {
                showNotification('Скопировано: ' + code);
                ipcRenderer.send('show-notification', 'Скопировано', code);
            });
        }

        // Показать уведомление
        function showNotification(message, isError = false) {
            const notification = document.getElementById('copiedNotice');
            notification.textContent = message;
            notification.style.backgroundColor = isError ? 'var(--danger)' : 'var(--success)';
            notification.style.display = 'block';
            setTimeout(() => notification.style.display = 'none', 2000);
        }

        // Функция для создания выпадающего списка категорий
        function createCategorySelect(currentCategoryId, index, type = 'move') {
            let selectHtml = `<select class="${type}-select" id="${type}-select-${currentCategoryId}-${index}">`;

            categories.forEach(category => {
                if (category.id !== currentCategoryId) {
                    selectHtml += `<option value="${category.id}">${category.name}</option>`;
                }
            });

            selectHtml += '</select>';
            return selectHtml;
        }

        // Функция для создания элементов списка
        async function createListItems(categoryId) {
            const category = getCategoryById(categoryId);
            if (!category) return;

            const items = getCategoryData(categoryId);
            const gridId = `${category.key}Grid`;

            // Создаем контейнер категории, если его нет
            let categoryContainer = document.getElementById(`${category.key}Category`);
            if (!categoryContainer) {
                categoryContainer = document.createElement('div');
                categoryContainer.className = 'category';
                categoryContainer.id = `${category.key}Category`;
                categoryContainer.style.borderColor = category.color;

                const heading = document.createElement('h2');
                heading.textContent = category.name;
                heading.style.borderBottomColor = category.color;
                heading.style.textShadow = `0 0 10px ${category.color}`;

                const gridContainer = document.createElement('div');
                gridContainer.className = 'items-grid';
                gridContainer.id = gridId;

                categoryContainer.appendChild(heading);
                categoryContainer.appendChild(gridContainer);
                document.getElementById('listContainer').appendChild(categoryContainer);
            } else {
                // Если контейнер уже есть, просто очищаем его
                const gridContainer = document.getElementById(gridId);
                if (gridContainer) {
                    gridContainer.innerHTML = '';
                }
            }

            // Добавляем элементы
            const gridContainer = document.getElementById(gridId);
            for (let index = 0; index < items.length; index++) {
                const item = items[index];
                const gifPath = await ipcRenderer.invoke('get-gif-path', item.gifId);

                const itemElement = document.createElement('div');
                itemElement.className = 'item-container';
                itemElement.style.borderColor = category.color;

                itemElement.innerHTML = `
    <button class="gif-delete-btn" onclick="deleteItem(${categoryId}, ${index})"></button>
    <div class="item-code">
        <button class="copy-btn" onclick="copyCode('${item.code}')" style="background-color: ${category.color}">Копировать</button>
        <span id="code-display-${categoryId}-${index}">${item.code}</span>
        <input type="text" id="code-edit-${categoryId}-${index}" value="${item.code}" style="display: none; width: 100%; padding: 5px; border-radius: 4px; border: 1px solid ${category.color}; background-color: rgba(0,0,0,0.5); color: white;">
    </div>
    <div class="gif-controls">
        <div class="gif-edit-container">
            <div class="gif-container" style="border-color: ${category.color}">
                <img src="${gifPath || ''}" alt="GIF" id="gif-${categoryId}-${index}">
            </div>
            <input type="text" class="gif-url-edit" id="gif-url-edit-${categoryId}-${index}" value="" placeholder="URL новой гифки">
        </div>
        <div class="edit-controls">
            <button class="edit-btn" onclick="toggleEditMode(${categoryId}, ${index})" id="edit-btn-${categoryId}-${index}">Редактировать</button>
            <button class="edit-btn" onclick="saveEdits(${categoryId}, ${index})" id="save-btn-${categoryId}-${index}" style="display: none; background-color: var(--success)">Сохранить</button>
            <button class="edit-btn" onclick="cancelEdits(${categoryId}, ${index})" id="cancel-btn-${categoryId}-${index}" style="display: none; background-color: var(--danger)">Отмена</button>
        </div>
<div class="action-container">
    <div class="action-row">
        <span class="action-label">Переместить:</span>
        <div class="category-dropdown-container">
            <button class="category-dropdown-btn" onclick="toggleCategoryDropdown('move', ${categoryId}, ${index})">
                Выбрать категорию
            </button>
            <div class="category-dropdown" id="move-dropdown-${categoryId}-${index}">
                ${categories.filter(c => c.id !== categoryId).map(c => `
                    <button onclick="moveItem(${categoryId}, ${index}, ${c.id})">${c.name}</button>
                `).join('')}
            </div>
        </div>
    </div>
    <div class="action-row">
        <span class="action-label">Копировать:</span>
        <div class="category-dropdown-container">
            <button class="category-dropdown-btn" onclick="toggleCategoryDropdown('copy', ${categoryId}, ${index})">
                Выбрать категорию
            </button>
            <div class="category-dropdown" id="copy-dropdown-${categoryId}-${index}">
                ${categories.filter(c => c.id !== categoryId).map(c => `
                    <button onclick="copyItem(${categoryId}, ${index}, ${c.id})">${c.name}</button>
                `).join('')}
            </div>
        </div>
    </div>
</div>
                </div>
            `;
                gridContainer.appendChild(itemElement);
            }
        }

        // Генерация звезд
        function createStars() {
            const starsContainer = document.getElementById('stars');
            const starsCount = 200;

            for (let i = 0; i < starsCount; i++) {
                const star = document.createElement('div');
                star.className = 'star';

                // Случайные параметры звезды
                const size = Math.random() * 2;
                const x = Math.random() * 100;
                const y = Math.random() * 100;
                const duration = 2 + Math.random() * 3 + 's';
                const delay = Math.random() * 5 + 's';

                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                star.style.left = `${x}%`;
                star.style.top = `${y}%`;
                star.style.setProperty('--duration', duration);
                star.style.animationDelay = delay;

                starsContainer.appendChild(star);
            }
        }

        // Генерация светящихся линий
        function createGlowingLines() {
            const background = document.querySelector('.space-background');
            const linesCount = 15;

            for (let i = 0; i < linesCount; i++) {
                const line = document.createElement('div');
                line.className = 'glowing-line';

                // Случайные параметры линии
                const width = 50 + Math.random() * 150;
                const height = 1 + Math.random() * 2;
                const x = Math.random() * 100;
                const y = Math.random() * 100;
                const angle = -30 + Math.random() * 60;
                const duration = 10 + Math.random() * 20 + 's';
                const delay = Math.random() * 15 + 's';

                line.style.width = `${width}px`;
                line.style.height = `${height}px`;
                line.style.left = `${x}%`;
                line.style.top = `${y}%`;
                line.style.transform = `rotate(${angle}deg)`;
                line.style.animationDuration = duration;
                line.style.animationDelay = delay;

                background.appendChild(line);
            }
        }

        async function updateCategoryUI() {
            const categorySelector = document.getElementById('categorySelector');
            if (!categorySelector) {
                console.error('categorySelector not found!');
                return;
            }

            // Полностью очищаем DOM контейнеры
            categorySelector.innerHTML = '';
            document.getElementById('listContainer').innerHTML = '';

            categories.forEach(category => {
                const container = document.createElement('div');
                container.className = 'category-btn-container';
                container.style.position = 'relative';
                container.style.display = 'inline-block';

                const btn = document.createElement('button');
                btn.className = 'category-btn';
                btn.textContent = category.name;
                btn.dataset.category = category.key;
                btn.style.backgroundColor = category.color;

                const menuTrigger = document.createElement('button');
                menuTrigger.className = 'category-menu-trigger';
                menuTrigger.innerHTML = '⋮';
                menuTrigger.title = 'Действия с категорией';

                const dropdownMenu = document.createElement('div');
                dropdownMenu.className = 'category-dropdown-menu';
                dropdownMenu.style.display = 'none';

                menuTrigger.addEventListener('click', (e) => {
                    e.stopPropagation();
                    document.querySelectorAll('.category-dropdown-menu').forEach(menu => {
                        if (menu !== dropdownMenu) menu.style.display = 'none';
                    });
                    dropdownMenu.style.display = dropdownMenu.style.display === 'block' ? 'none' : 'block';
                });

                const editBtn = document.createElement('button');
                editBtn.className = 'edit-btn';
                editBtn.textContent = 'Редактировать';
                editBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    dropdownMenu.style.display = 'none';
                    openEditCategoryModal(category);
                });

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.textContent = 'Удалить';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    dropdownMenu.style.display = 'none';
                    deleteCategory(category.id);
                });

                dropdownMenu.appendChild(editBtn);
                dropdownMenu.appendChild(deleteBtn);
                btn.appendChild(menuTrigger);
                container.appendChild(btn);
                container.appendChild(dropdownMenu);

                btn.addEventListener('click', function (e) {
                    if (!menuTrigger.contains(e.target)) {
                        switchCategory(this.dataset.category);
                    }
                });

                categorySelector.appendChild(container);
            });

            updateCategorySelect();

            await Promise.all(categories.map(category => createListItems(category.id)));

            updateGifPanel();
        }
        // Обновление выпадающего списка категорий
        function updateCategorySelect() {
            const categorySelect = document.getElementById('newCategory');
            if (!categorySelect) return;

            categorySelect.innerHTML = '';
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category.id;
                option.textContent = category.name;
                categorySelect.appendChild(option);
            });
        }

        // Функция для удаления категории
        async function deleteCategory(categoryId) {
            const category = getCategoryById(categoryId);
            if (!category) return;

            // Кастомное подтверждение с отображением количества элементов
            const isConfirmed = await customConfirm(
                `Вы уверены, что хотите удалить категорию "${category.name}" и все её элементы (${itemsData[categoryId]?.length || 0} шт.)?`,
                'Подтвердите удаление категории'
            );

            if (!isConfirmed) return;

            try {
                // Удаляем все GIF-файлы категории асинхронно
                const deletePromises = (itemsData[categoryId] || []).map(item =>
                    ipcRenderer.invoke('delete-gif', item.gifId).catch(e => {
                        console.error(`Ошибка удаления GIF ${item.gifId}:`, e);
                        return false;
                    })
                );

                // Ждем завершения всех удалений
                const deleteResults = await Promise.all(deletePromises);
                const hasErrors = deleteResults.some(result => result === false);

                if (hasErrors) {
                    showNotification('Некоторые GIF не удалены (см. консоль)', true);
                }

                // Удаляем категорию из списка
                categories = categories.filter(c => c.id !== categoryId);
                delete itemsData[categoryId];

                // Сохраняем данные
                await saveAllData();

                // Удаляем DOM-элемент
                const categoryContainer = document.getElementById(`${category.key}Category`);
                if (categoryContainer) {
                    categoryContainer.remove();
                }

                // Обновляем UI
                await updateCategoryUI();

                // Переключаем категорию с проверкой существования
                if (categories.length > 0) {
                    const firstCategory = categories.find(c => document.getElementById(`${c.key}Category`));
                    if (firstCategory) {
                        switchCategory(firstCategory.key);
                    }
                }

                showNotification(`Категория "${category.name}" удалена`);

                // Восстанавливаем фокус
                setTimeout(() => {
                    const firstInput = document.querySelector('input, textarea, select');
                    if (firstInput) {
                        firstInput.focus({ preventScroll: true });
                        if (document.activeElement !== firstInput) {
                            ipcRenderer.send('force-focus', firstInput.id);
                        }
                    }
                }, 100);

            } catch (error) {
                console.error('Ошибка при удалении категории:', error);
                showNotification('Ошибка при удалении категории', true);
            }
        }

        function openEditCategoryModal(category) {
            document.getElementById('editCategoryName').value = category.name;
            document.getElementById('editCategoryModal').dataset.categoryId = category.id;
            selectedColor = category.color;

            // Инициализируем палитру
            setTimeout(() => {
                setupEditColorWheel(category.color);
            }, 50);

            openModal('editCategoryModal');
        }

        // Функция для настройки цветового колеса редактирования
        function setupEditColorWheel(initialColor) {
            const canvas = document.getElementById('editColorPalette');
            const ctx = canvas.getContext('2d');
            const selector = document.getElementById('editPaletteSelector');
            const preview = document.getElementById('editColorPreview');

            // Рисуем палитру (аналогично setupColorWheel)
            function drawPalette() {
                const width = canvas.width;
                const height = canvas.height;
                const hGrad = ctx.createLinearGradient(0, 0, width, 0);
                hGrad.addColorStop(0, 'red');
                hGrad.addColorStop(0.17, 'yellow');
                hGrad.addColorStop(0.34, 'lime');
                hGrad.addColorStop(0.51, 'cyan');
                hGrad.addColorStop(0.68, 'blue');
                hGrad.addColorStop(0.85, 'magenta');
                hGrad.addColorStop(1, 'red');
                ctx.fillStyle = hGrad;
                ctx.fillRect(0, 0, width, height);

                const vGrad = ctx.createLinearGradient(0, 0, 0, height);
                vGrad.addColorStop(0, 'rgba(255,255,255,1)');
                vGrad.addColorStop(0.5, 'rgba(255,255,255,0)');
                vGrad.addColorStop(0.5, 'rgba(0,0,0,0)');
                vGrad.addColorStop(1, 'rgba(0,0,0,1)');
                ctx.fillStyle = vGrad;
                ctx.fillRect(0, 0, width, height);
            }

            drawPalette();

            let isDown = false;

            // Устанавливаем начальный цвет
            preview.style.backgroundColor = initialColor;

            // Находим позицию цвета на палитре
            const hsl = hexToHsl(initialColor);
            const x = Math.round(hsl.h * canvas.width);
            const y = canvas.height - Math.round(hsl.s * canvas.height / 2 + (1 - hsl.l) * canvas.height / 2);

            selector.style.left = x + 'px';
            selector.style.top = y + 'px';

            function getColor(x, y) {
                const data = ctx.getImageData(x, y, 1, 1).data;
                return rgbToHex(data[0], data[1], data[2]);
            }

            function update(x, y) {
                selector.style.left = x + 'px';
                selector.style.top = y + 'px';
                const color = getColor(x, y);
                preview.style.backgroundColor = color;
                selectedColor = color;
            }

            canvas.addEventListener('mousedown', (e) => {
                isDown = true;
                const rect = canvas.getBoundingClientRect();
                const x = Math.max(0, Math.min(e.clientX - rect.left, canvas.width));
                const y = Math.max(0, Math.min(e.clientY - rect.top, canvas.height));
                update(x, y);
            });

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = Math.max(0, Math.min(e.clientX - rect.left, canvas.width));
                const y = Math.max(0, Math.min(e.clientY - rect.top, canvas.height));
                if (isDown) {
                    update(x, y);
                }
            });

            document.addEventListener('mouseup', () => {
                isDown = false;
            });
        }

        // Выпадающие окна выбора категории при перемещении и копировании
        function toggleCategoryDropdown(type, categoryId, index) {
            const dropdownId = `${type}-dropdown-${categoryId}-${index}`;
            const dropdown = document.getElementById(dropdownId);

            // Закрываем все другие выпадающие меню
            document.querySelectorAll('.category-dropdown').forEach(d => {
                if (d.id !== dropdownId) d.style.display = 'none';
            });

            // Переключаем текущее меню
            dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';

            // Закрытие при клике вне меню
            if (dropdown.style.display === 'block') {
                const closeHandler = (e) => {
                    if (!dropdown.contains(e.target) && e.target.className !== 'category-dropdown-btn') {
                        dropdown.style.display = 'none';
                        document.removeEventListener('click', closeHandler);
                    }
                };
                setTimeout(() => document.addEventListener('click', closeHandler), 0);
            }
        }

        // Функция для сохранения изменений категории
        async function saveCategoryChanges() {
            const categoryId = parseInt(document.getElementById('editCategoryModal').dataset.categoryId);
            const newName = document.getElementById('editCategoryName').value.trim();
            const newColor = selectedColor;

            if (!newName) {
                alert("Пожалуйста, введите название категории");
                return;
            }

            const category = getCategoryById(categoryId);
            if (!category) return;

            // Проверяем, нет ли уже категории с таким именем (кроме текущей)
            if (categories.some(c => c.id !== categoryId && c.name.toLowerCase() === newName.toLowerCase())) {
                alert("Категория с таким названием уже существует");
                return;
            }

            // Обновляем категорию
            category.name = newName;
            category.color = newColor;
            category.key = createCategoryKey(newName);

            // Сохраняем данные
            await saveAllData();

            // Обновляем UI
            await updateCategoryUI();

            // Закрываем модальное окно
            closeModal('editCategoryModal');
        }

        // Функция для кастомного подтверждения
        async function customConfirm(message, title = 'Подтверждение') {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirmModal');
                document.getElementById('confirmModalMessage').textContent = message;
                document.getElementById('confirmModalTitle').textContent = title;

                const yesBtn = document.getElementById('confirmModalYes');
                const noBtn = document.getElementById('confirmModalNo');

                // Удаляем старые обработчики
                yesBtn.onclick = null;
                noBtn.onclick = null;

                // Добавляем новые
                yesBtn.onclick = () => {
                    closeConfirmModal();
                    resolve(true);
                };

                noBtn.onclick = () => {
                    closeConfirmModal();
                    resolve(false);
                };

                modal.style.display = 'flex';
            });
        }

        function closeConfirmModal() {
            document.getElementById('confirmModal').style.display = 'none';
        }

        // Функция для перемещения элемента между категориями
        async function moveItem(fromCategoryId, index, toCategoryId = null) {
            if (!toCategoryId) {
                const selectId = `move-select-${fromCategoryId}-${index}`;
                toCategoryId = parseInt(document.getElementById(selectId).value);
            }

            const toCategory = getCategoryById(toCategoryId);
            if (!toCategory) return;

            // Используем кастомное подтверждение
            const isConfirmed = await customConfirm(
                `Переместить элемент в категорию "${toCategory.name}"?`,
                'Подтвердите перемещение'
            );

            if (!isConfirmed) return;

            // Логика перемещения
            const originalItem = itemsData[fromCategoryId][index];
            const itemClone = { code: originalItem.code, gifId: originalItem.gifId };

            itemsData[fromCategoryId].splice(index, 1);
            if (!itemsData[toCategoryId]) itemsData[toCategoryId] = [];
            itemsData[toCategoryId].push(itemClone);

            await saveAllData();
            await updateCategoryUI();
        }

        // Функция для копирования элемента в другую категорию
        async function copyItem(fromCategoryId, index, toCategoryId = null) {
            if (!toCategoryId) {
                const selectId = `copy-select-${fromCategoryId}-${index}`;
                toCategoryId = parseInt(document.getElementById(selectId).value);
            }

            const toCategory = getCategoryById(toCategoryId);
            if (!toCategory) return;

            // Заменяем confirm на кастомное модальное окно
            const isConfirmed = await customConfirm(
                `Скопировать элемент в категорию "${toCategory.name}"?`,
                'Подтвердите копирование'
            );

            if (!isConfirmed) return;

            const originalItem = itemsData[fromCategoryId][index];

            // Создаем новый gifId для копии
            const newGifId = `gif_${generateId()}`;

            // Копируем сам файл
            const copySuccess = await ipcRenderer.invoke('copy-gif-file', {
                fromGifId: originalItem.gifId,
                toGifId: newGifId
            });

            if (!copySuccess) {
                // Заменяем alert на кастомное уведомление
                showNotification("Не удалось скопировать GIF файл!", true);
                return;
            }

            const newItem = {
                code: originalItem.code,
                gifId: newGifId
            };

            if (!itemsData[toCategoryId]) itemsData[toCategoryId] = [];
            itemsData[toCategoryId].push(newItem);

            await saveAllData();
            await updateCategoryUI();
            showNotification(`Элемент скопирован в "${toCategory.name}"`);

            // Возвращаем фокус
            setTimeout(() => {
                const input = document.getElementById('newCategoryName');
                if (input) input.focus();
            }, 50);
        }

        // Функция для добавления нового элемента
        async function addNewItem() {
            const categoryId = parseInt(document.getElementById('newCategory').value);
            const code = document.getElementById('newCode').value.trim();
            const gifUrl = document.getElementById('newGifUrl').value.trim();

            if (!code) {
                alert("Пожалуйста, введите код");
                return;
            }

            const gifId = `gif_${generateId()}`; // Генерируем уникальный ID для гифки
            const newItem = { code, gifId };

            if (!itemsData[categoryId]) itemsData[categoryId] = [];
            itemsData[categoryId].push(newItem);

            // Сохраняем данные
            await saveAllData();

            if (gifUrl) {
                await ipcRenderer.invoke('save-gif', { gifId, url: gifUrl });
            }

            // Обновляем UI
            await updateCategoryUI();

            // Очищаем поля формы
            document.getElementById('newCode').value = '';
            document.getElementById('newGifUrl').value = '';
        }

        // Функция для создания новой категории
        async function createNewCategory() {
            const name = document.getElementById('newCategoryName').value.trim();
            const color = selectedColor;

            if (!name) {
                alert("Пожалуйста, введите название категории");
                return;
            }

            // Проверяем, нет ли уже категории с таким именем
            if (categories.some(c => c.name.toLowerCase() === name.toLowerCase())) {
                alert("Категория с таким названием уже существует");
                return;
            }

            const newCategory = {
                id: generateId(),
                name: name,
                key: createCategoryKey(name),
                color: color
            };

            categories.push(newCategory);
            itemsData[newCategory.id] = [];

            // Сохраняем данные
            await saveAllData();

            // Обновляем UI
            await updateCategoryUI();

            // Переключаемся на новую категорию
            switchCategory(newCategory.key);

            // Очищаем форму
            document.getElementById('newCategoryName').value = '';
        }

        // Функция для удаления элемента
        async function deleteItem(categoryId, index) {
            const category = getCategoryById(categoryId);
            if (!category) return;

            // Заменяем confirm на кастомное модальное окно
            const isConfirmed = await customConfirm(
                `Удалить элемент "${itemsData[categoryId][index].code}" из категории "${category.name}"?`,
                'Подтвердите удаление'
            );

            if (!isConfirmed) return;

            const gifId = itemsData[categoryId][index].gifId;

            // Удаляем из массива
            itemsData[categoryId].splice(index, 1);

            // Удаляем файл GIF
            const deleteSuccess = await ipcRenderer.invoke('delete-gif', gifId);

            if (!deleteSuccess) {
                showNotification("Не удалось удалить GIF файл!", true);
                return;
            }

            await saveAllData();
            await updateCategoryUI();
            showNotification('Элемент удалён');

            // Возвращаем фокус безопасным способом
            setTimeout(() => {
                const input = document.getElementById('newGifUrl');
                if (input) {
                    input.focus();
                    // Дополнительная проверка (для Electron)
                    if (document.activeElement !== input) {
                        input.focus({ preventScroll: true });
                    }
                }
            }, 50);
        }

        // Функция для сохранения всех данных
        async function saveAllData() {
            const data = {
                categories,
                itemsData,
                gifs: await getAllGifs()
            };

            // Сохраняем только данные, без полного обновления UI
            return await ipcRenderer.invoke('save-data', data);
        }

        // Функция для получения всех GIF
        async function getAllGifs() {
            return await ipcRenderer.invoke('get-all-gifs');
        }

        // Функция экспорта данных
        async function exportData() {
            const data = {
                version: 3,
                categories: categories,
                itemsData: itemsData,
                gifs: await getAllGifs(),
                updatedAt: new Date().toISOString()
            };

            const result = await ipcRenderer.invoke('export-data', data);
            if (result) {
                showNotification('Данные успешно экспортированы');
            }
        }

        // Функция импорта данных
        let importInProgress = false;
        async function importData() {
            try {
                const result = await ipcRenderer.invoke('import-data');
                if (result) {
                    showNotification(`Импорт завершен! Категорий: ${result.categories.length}, Элементов: ${Object.values(result.itemsData).reduce((acc, items) => acc + items.length, 0)}`);
                    // Обновляем UI
                    categories = result.categories;
                    itemsData = result.itemsData;
                    await updateCategoryUI();
                }
            } catch (error) {
                console.error('Import error:', error);
                showNotification('Ошибка импорта', error.message);
            }
        }

        // Функция открытия модального окна экспорта
        function openExportModal() {
            const container = document.querySelector('.categories-checkbox-container');
            container.innerHTML = '';

            categories.forEach(category => {
                const item = document.createElement('div');
                item.className = 'category-checkbox-item';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `export-cat-${category.id}`;
                checkbox.checked = true; // По умолчанию все выбраны

                const label = document.createElement('label');
                label.htmlFor = `export-cat-${category.id}`;
                label.textContent = category.name;

                const colorPreview = document.createElement('div');
                colorPreview.className = 'category-color-preview';
                colorPreview.style.backgroundColor = category.color;

                item.appendChild(checkbox);
                item.appendChild(label);
                item.appendChild(colorPreview);
                container.appendChild(item);
            });

            openModal('exportModal');
        }

        // Функция экспорта выбранных категорий
        async function exportSelectedCategories() {
            const checkboxes = document.querySelectorAll('.categories-checkbox-container input[type="checkbox"]');
            const selectedCategories = [];

            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    const categoryId = parseInt(checkbox.id.replace('export-cat-', ''));
                    selectedCategories.push(categoryId);
                }
            });

            if (selectedCategories.length === 0) {
                alert('Пожалуйста, выберите хотя бы одну категорию для экспорта');
                return;
            }

            // Подготавливаем данные
            const exportData = {
                categories: categories.filter(cat => selectedCategories.includes(cat.id)),
                itemsData: {},
                gifs: await getAllGifs()
            };

            selectedCategories.forEach(catId => {
                if (itemsData[catId]) {
                    exportData.itemsData[catId] = itemsData[catId];
                }
            });

            // Закрываем модалку выбора категорий
            closeModal('exportModal');

            // Получаем информацию о выбранных данных
            const { data, gifCount } = await ipcRenderer.invoke('export-data', exportData);

            // Теперь открываем диалог сохранения файла
            const { filePath } = await ipcRenderer.invoke('show-save-dialog', {
                title: 'Сохранить экспортированные данные',
                defaultPath: `gif_export_${new Date().toISOString().slice(0, 10)}.zip`,
                filters: [{ name: 'ZIP Archive', extensions: ['zip'] }]
            });

            if (filePath) {
                const success = await ipcRenderer.invoke('save-export-file', {
                    exportData: data,
                    filePath
                });

                if (success) {
                    showNotification(`Экспортировано: ${selectedCategories.length} категорий, ${gifCount} GIF`);
                }
            }
        }

        // Функция переключения категорий
        function switchCategory(categoryKey) {
            // Обновляем активные кнопки
            document.querySelectorAll('.category-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.category === categoryKey) {
                    btn.classList.add('active');
                }
            });

            // Обновляем активные категории
            document.querySelectorAll('.category').forEach(cat => {
                cat.classList.remove('active');
                if (cat.id === `${categoryKey}Category`) {
                    cat.classList.add('active');
                }
            });
        }

        // Функция для обновления GIF панели
        async function updateGifPanel() {
            // Обновляем категории
            const panelCategories = document.getElementById('panelCategories');
            panelCategories.innerHTML = '';

            categories.forEach((category, index) => {
                const btn = document.createElement('button');
                btn.className = 'panel-category-btn';
                btn.textContent = category.name;
                btn.style.backgroundColor = category.color;
                btn.dataset.index = index;

                if (panelState.currentCategory === category.id) {
                    btn.classList.add('active');
                }


                // Обработчик клика по категории
                btn.addEventListener('click', (e) => {
                    if (panelState.isDraggingCategory || e.target.classList.contains('drag-handle')) {
                        return;
                    }
                    panelState.currentCategory = category.id;
                    updateGifPanel();
                });

                // Обработчики для перетаскивания категорий
                btn.addEventListener('mousedown', startCategoryDrag);

                panelCategories.appendChild(btn);
            });

            if (!panelState.currentCategory && categories.length > 0) {
                panelState.currentCategory = categories[0].id;
            }

            // Обновляем элементы
            const panelItemsGrid = document.getElementById('panelItemsGrid');
            panelItemsGrid.innerHTML = '';

            if (!panelState.currentCategory) return;

            const items = itemsData[panelState.currentCategory] || [];

            for (let index = 0; index < items.length; index++) {
                const item = items[index];
                const gifPath = await ipcRenderer.invoke('get-gif-path', item.gifId);

                const itemElement = document.createElement('div');
                itemElement.className = 'panel-gif-item';
                itemElement.title = item.code;

                const img = document.createElement('img');
                img.src = gifPath || '';
                img.alt = item.code;

                const codeElement = document.createElement('div');
                codeElement.className = 'panel-gif-code';
                codeElement.textContent = item.code.length > 10 ?
                    item.code.substring(0, 8) + '...' : item.code;

                itemElement.appendChild(img);
                itemElement.appendChild(codeElement);

                itemElement.addEventListener('click', () => {
                    copyCode(item.code);
                });

                panelItemsGrid.appendChild(itemElement);
            }
        }



        // Улучшенный код для работы с цветовым колесом
        function setupColorWheel() {
            const canvas = document.getElementById('colorPalette');
            const ctx = canvas.getContext('2d');
            const selector = document.getElementById('paletteSelector');
            const preview = document.getElementById('colorPreview');
            const value = preview.querySelector('.color-value');

            // Рисуем квадратную палитру
            function drawPalette() {
                const width = canvas.width;
                const height = canvas.height;
                // Градиент по горизонтали (цветовой тон)
                const hGrad = ctx.createLinearGradient(0, 0, width, 0);
                hGrad.addColorStop(0, 'red');
                hGrad.addColorStop(0.17, 'yellow');
                hGrad.addColorStop(0.34, 'lime');
                hGrad.addColorStop(0.51, 'cyan');
                hGrad.addColorStop(0.68, 'blue');
                hGrad.addColorStop(0.85, 'magenta');
                hGrad.addColorStop(1, 'red');
                ctx.fillStyle = hGrad;
                ctx.fillRect(0, 0, width, height);

                // Градиент по вертикали (яркость)
                const vGrad = ctx.createLinearGradient(0, 0, 0, height);
                vGrad.addColorStop(0, 'rgba(255,255,255,1)');
                vGrad.addColorStop(0.5, 'rgba(255,255,255,0)');
                vGrad.addColorStop(0.5, 'rgba(0,0,0,0)');
                vGrad.addColorStop(1, 'rgba(0,0,0,1)');
                ctx.fillStyle = vGrad;
                ctx.fillRect(0, 0, width, height);
            }

            drawPalette();

            let isDown = false;
            let currentColor = '#4361ee';

            function getColor(x, y) {
                const data = ctx.getImageData(x, y, 1, 1).data;
                return rgbToHex(data[0], data[1], data[2]);
            }

            function update(x, y) {
                selector.style.left = x + 'px';
                selector.style.top = y + 'px';
                const color = getColor(x, y);
                preview.style.backgroundColor = color;
                selectedColor = color;
            }

            canvas.addEventListener('mousedown', (e) => {
                isDown = true;
                const rect = canvas.getBoundingClientRect();
                const x = Math.max(0, Math.min(e.clientX - rect.left, canvas.width));
                const y = Math.max(0, Math.min(e.clientY - rect.top, canvas.height));
                update(x, y);
            });

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = Math.max(0, Math.min(e.clientX - rect.left, canvas.width));
                const y = Math.max(0, Math.min(e.clientY - rect.top, canvas.height));
                if (isDown) {
                    update(x, y);
                }
            });

            document.addEventListener('mouseup', () => {
                isDown = false;
            });

            // Утилита для HEX
            function rgbToHex(r, g, b) {
                return '#' + [r, g, b].map(v => v.toString(16).padStart(2, '0')).join('');
            }

            // Инициализация
            update(100, 100);
        }


        // Дополнительные функции для работы с цветом
        function hexToHsl(hex) {
            // Конвертация HEX в RGB
            const r = parseInt(hex.substring(1, 3), 16) / 255;
            const g = parseInt(hex.substring(3, 5), 16) / 255;
            const b = parseInt(hex.substring(5, 7), 16) / 255;

            // Конвертация RGB в HSL
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }

            return { h, s, l };
        }

        function hslToRgb(h, s, l) {
            let r, g, b;

            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                };

                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;

                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }

            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(x => {
                const hex = x.toString(16).padStart(2, '0');
                return hex;
            }).join('');
        }

        // Функции для работы с модальными окнами
        function openModal(modalId) {
            document.getElementById(modalId).style.display = 'flex';
            // Обновляем данные в модальном окне при открытии
            if (modalId === 'addGifModal') {
                updateCategorySelect();
            }
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
            // Очищаем поля при закрытии
            if (modalId === 'addGifModal') {
                document.getElementById('newCode').value = '';
                document.getElementById('newGifUrl').value = '';
            } else if (modalId === 'addCategoryModal') {
                document.getElementById('newCategoryName').value = '';
            }
        }

        // Функция для переключения панели
        function toggleGifPanel() {
            ipcRenderer.send('toggle-gif-panel');
        }

        // Функция для обновления состояния кнопки
        async function updatePanelButton() {
            const btn = document.getElementById('toggleGifPanelBtn');
            if (!btn) return;

            const isOpen = await ipcRenderer.invoke('is-gif-panel-open');
            btn.textContent = isOpen ? 'Закрыть GIF панель' : 'Открыть GIF панель';
        }

        // Функция для переключения режима редактирования
        function toggleEditMode(categoryId, index) {
            const displayElement = document.getElementById(`code-display-${categoryId}-${index}`);
            const editElement = document.getElementById(`code-edit-${categoryId}-${index}`);
            const gifUrlElement = document.getElementById(`gif-url-edit-${categoryId}-${index}`);
            const editBtn = document.getElementById(`edit-btn-${categoryId}-${index}`);
            const saveBtn = document.getElementById(`save-btn-${categoryId}-${index}`);
            const cancelBtn = document.getElementById(`cancel-btn-${categoryId}-${index}`);

            // Переключаем видимость элементов
            const isEditing = displayElement.style.display === 'none';
            displayElement.style.display = isEditing ? 'inline' : 'none';
            editElement.style.display = isEditing ? 'none' : 'block';
            gifUrlElement.style.display = isEditing ? 'none' : 'block';
            editBtn.style.display = isEditing ? 'inline-block' : 'none';
            saveBtn.style.display = isEditing ? 'none' : 'inline-block';
            cancelBtn.style.display = isEditing ? 'none' : 'inline-block';

            // Если включаем редактирование, загружаем URL гифки
            if (!isEditing) {
                loadGifUrl(categoryId, index);
            }
        }

        // Функция для загрузки URL гифки
        async function loadGifUrl(categoryId, index) {
            const item = itemsData[categoryId][index];
            const gifUrlElement = document.getElementById(`gif-url-edit-${categoryId}-${index}`);

            try {
                const url = await ipcRenderer.invoke('get-gif-url', item.gifId);
                gifUrlElement.value = url || '';
            } catch (error) {
                console.error('Error loading GIF URL:', error);
                gifUrlElement.value = '';
            }
        }

        // Функция для сохранения изменений
        async function saveEdits(categoryId, index) {
            const editElement = document.getElementById(`code-edit-${categoryId}-${index}`);
            const gifUrlElement = document.getElementById(`gif-url-edit-${categoryId}-${index}`);
            const newCode = editElement.value.trim();
            const newUrl = gifUrlElement.value.trim();

            if (!newCode) {
                alert('Пожалуйста, введите код');
                return;
            }

            // Обновляем код
            itemsData[categoryId][index].code = newCode;

            // Если URL изменился, обновляем гифку
            if (newUrl) {
                try {
                    await ipcRenderer.invoke('update-gif-url', {
                        gifId: itemsData[categoryId][index].gifId,
                        url: newUrl
                    });
                } catch (error) {
                    console.error('Error updating GIF:', error);
                    showNotification('Ошибка при обновлении GIF', true);
                }
            }

            // Сохраняем изменения
            await saveAllData();

            // Выходим из режима редактирования
            toggleEditMode(categoryId, index);

            // Обновляем отображение кода
            document.getElementById(`code-display-${categoryId}-${index}`).textContent = newCode;

            showNotification('Изменения сохранены');
        }

        // Функция для отмены изменений
        function cancelEdits(categoryId, index) {
            const item = itemsData[categoryId][index];
            const editElement = document.getElementById(`code-edit-${categoryId}-${index}`);

            // Восстанавливаем исходное значение
            editElement.value = item.code;

            // Выходим из режима редактирования
            toggleEditMode(categoryId, index);
        }

        // Обработчик изменения состояния панели
        ipcRenderer.on('gif-panel-state-changed', (event, isOpen) => {
            updatePanelButton();
        });

        // обработчик обновления данных в панели GIF
        ipcRenderer.on('data-updated', async (event, data) => {
            if (data) {
                categories = data.categories || [];
                itemsData = data.itemsData || {};
            } else {
                // Если data не передана, загружаем данные заново
                const loadedData = await ipcRenderer.invoke('load-initial-data');
                categories = loadedData.categories || [];
                itemsData = loadedData.itemsData || {};
            }

            // Обновляем UI
            await updateCategoryUI();

            // Если есть активная категория, переключаемся на нее
            if (categories.length > 0) {
                const activeCategory = document.querySelector('.category-btn.active');
                if (activeCategory) {
                    switchCategory(activeCategory.dataset.category);
                } else {
                    switchCategory(categories[0].key);
                }
            }
        });

        // Инициализация при загрузке страницы
        window.onload = async function () {
            // Создаем звезды и линии
            createStars();
            createGlowingLines()
            // Загружаем начальные данные
            const initialData = await ipcRenderer.invoke('load-initial-data');
            if (initialData) {
                categories = initialData.categories || [];
                itemsData = initialData.itemsData || {};
            }

            // Инициализируем UI
            await updateCategoryUI();

            // Переключаемся на первую категорию
            if (categories.length > 0) {
                switchCategory(categories[0].key);
            }

            // Инициализируем цветовое колесо
            setupColorWheel();

            document.getElementById('toggleGifPanelBtn').addEventListener('click', toggleGifPanel);
            updatePanelButton(); // Инициализация текста кнопки

            // Обработчики кнопок
            document.getElementById('openAddGifModal').addEventListener('click', () => openModal('addGifModal'));
            document.getElementById('openAddCategoryModal').addEventListener('click', () => openModal('addCategoryModal'));
            document.getElementById('exportBtn').addEventListener('click', exportData);
            document.getElementById('importBtn').addEventListener('click', async () => {
                const confirmed = confirm('Импортировать данные? Существующие данные не будут удалены, а объединятся с импортированными.');
                if (confirmed) {
                    const result = await ipcRenderer.invoke('import-data');
                    if (result) {
                        showNotification(`Импорт завершен! Категорий: ${result.categories.length}, Элементов: ${Object.values(result.itemsData).reduce((acc, items) => acc + items.length, 0)
                            }`);
                    }
                }
            });
            document.getElementById('saveCategoryBtn').addEventListener('click', saveCategoryChanges);
            document.getElementById('exportBtn').addEventListener('click', openExportModal);
            document.getElementById('confirmExportBtn').addEventListener('click', exportSelectedCategories);


            // Обработчики для модальных окон
            document.getElementById('addNewBtn').addEventListener('click', async function () {
                await addNewItem();
                closeModal('addGifModal');
            });

            document.getElementById('createCategoryBtn').addEventListener('click', async function () {
                await createNewCategory();
                closeModal('addCategoryModal');
            });

            // Обработчики закрытия модальных окон
            document.querySelectorAll('.close-modal, .cancel-btn').forEach(btn => {
                btn.addEventListener('click', function () {
                    const modal = this.closest('.modal');
                    closeModal(modal.id);
                });
            });

            // Закрытие модального окна при клике вне его
            window.addEventListener('click', function (event) {
                if (event.target.classList.contains('modal')) {
                    closeModal(event.target.id);
                }
            });

            document.addEventListener('click', function (e) {
                if (!e.target.closest('.category-menu-trigger') && !e.target.closest('.category-dropdown-menu')) {
                    document.querySelectorAll('.category-dropdown-menu').forEach(menu => {
                        menu.classList.remove('show');
                    });
                }
            });

            // Обработчики для GIF панели
            document.getElementById('togglePanelBtn').addEventListener('click', toggleGifPanel);
            document.getElementById('pinPanelBtn').addEventListener('click', togglePinPanel);
            document.getElementById('refreshPanelBtn').addEventListener('click', refreshPanelData);
            document.getElementById('minimizePanelBtn').addEventListener('click', minimizePanel);
            document.getElementById('closePanelBtn').addEventListener('click', toggleGifPanel);
            document.getElementById('settingsPanelBtn').addEventListener('click', showSettingsModal);

            // Обработчики перемещения панели
            document.getElementById('panelHeader').addEventListener('mousedown', startPanelDrag);
            document.addEventListener('mousemove', dragPanel);
            document.addEventListener('mouseup', stopPanelDrag);

            // Обработчики модального окна настроек
            document.getElementById('closeSettingsBtn').addEventListener('click', hideSettingsModal);
            document.getElementById('saveSettingsBtn').addEventListener('click', saveHotkeySettings);
            document.getElementById('resetSettingsBtn').addEventListener('click', resetHotkeySettings);

            // Обработчики ввода горячих клавиш
            setupHotkeyInputs();

            // Обработчики горячих клавиш
            document.addEventListener('keydown', handleHotkeys);

            // Обновляем подсказку о горячих клавишах
            updateHotkeyHint();

            // Обновляем кнопку закрепления
            updatePinButton();
            document.addEventListener('click', function (e) {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                    e.target.focus();
                }
            });
        };

    </script>
</body>

</html>